-- Project Component Specification
--
-- Project registry + EQL wiring for orchestration.
-- Manages a set of registered projects (keyed by canonical filesystem path)
-- and provides the concrete execute!, invoke-skill!, and escalate-to-dev-env!
-- mutations that the orchestration statechart entry actions call.
--
-- Additive to orchestration.allium: this spec supplies the implementation
-- details for Execute, InvokeSkill, and EscalateToDevEnv rules without
-- duplicating state derivation, statechart definitions, or abstract
-- execution rules already specified there.
--
-- Naming: allium uses snake_case; the Clojure implementation uses kebab-case.

use orchestration


-- External Entities

external entity PathomGraph {
    -- The shared Pathom3 graph.  Resolvers and mutations auto-register
    -- on namespace load via pathom-graph component macros.
    env: Map
}

external entity FileSystem {
    -- Path canonicalization via java.io.File.
    -- Used by registry to resolve symlinks to absolute paths.
}


-- Value Types

value RegistrationResult {
    -- Returned by Register rule.
    project: Project?                              -- present on success
    error: path_not_found | not_a_directory
         | duplicate_path | duplicate_name?        -- present on failure
    message: String?
}

value UpdateResult {
    -- Returned by UpdateProject rule.
    project: Project?                              -- present on success
    error: project_not_found | duplicate_name?     -- present on failure
    message: String?
}


-- Entities

entity Project {
    path: String                                   -- canonical absolute filesystem path
    name: String                                   -- unique display name

    -- Derived
    path_segment: FileSystem.file_name(path)       -- final segment of path
}

entity ProjectRegistry {
    -- In-memory atom, keyed by canonical path.
    -- Singleton: one registry per JVM.
    entries: Map<String, Project>                   -- canonical path -> Project

    -- Derived
    all_projects: entries.values
}


-- Config

config {
    updatable_keys: Set<String> = { "name" }       -- only :project/name can be modified
}


-- Rules

--- Registry Operations

rule Canonicalize {
    -- Resolve path to canonical absolute form via java.io.File.getCanonicalPath.
    when: CanonicalizeRequested(path)
    ensures: result = FileSystem.canonical_path(path)
}

rule ValidatePath {
    -- Check path exists and is a directory.
    when: ValidatePathRequested(path)
    ensures: result =
        if not FileSystem.exists(path):
            { error: path_not_found, message: "Path does not exist: " + path }
        else if not FileSystem.is_directory(path):
            { error: not_a_directory, message: "Path is not a directory: " + path }
        else:
            nil
}

rule Register {
    -- Create project at path.  Name defaults to final path segment.
    -- Validates path, canonicalizes, checks path and name uniqueness.
    when: RegisterRequested(registry, path, name?)
    let canonical = Canonicalize(path)
    let validation = ValidatePath(canonical)
    requires: validation = nil
    let effective_name = name or Project.path_segment(canonical)
    requires: registry.entries.get(canonical) = nil
        -- error: duplicate_path
    requires: registry.all_projects.none(p => p.name = effective_name)
        -- error: duplicate_name
    let project = Project { path: canonical, name: effective_name }
    ensures: registry.entries.put(canonical, project)
    ensures: result = RegistrationResult { project: project }
}

rule Unregister {
    -- Remove project by path.  Returns removed project or nil.
    when: UnregisterRequested(registry, path)
    let canonical = Canonicalize(path)
    let existing = registry.entries.get(canonical)
    ensures: registry.entries.remove(canonical)
    ensures: result = existing
}

rule UpdateProject {
    -- Update project name.  Only :project/name can be modified.
    -- Checks name uniqueness against other projects.
    when: UpdateProjectRequested(registry, path, updates)
    let canonical = Canonicalize(path)
    let existing = registry.entries.get(canonical)
    requires: existing exists
        -- error: project_not_found
    let allowed = updates restricted to config.updatable_keys
    let new_name = allowed.name
    requires:
        if new_name exists and new_name != existing.name:
            registry.all_projects.none(p => p.name = new_name)
            -- error: duplicate_name
    let updated = existing merged with allowed
    ensures: registry.entries.put(canonical, updated)
    ensures: result = UpdateResult { project: updated }
}

rule GetByPath {
    -- Lookup project by canonical path.
    when: GetByPathRequested(registry, path)
    let canonical = Canonicalize(path)
    ensures: result = registry.entries.get(canonical)
}

rule GetByName {
    -- Lookup project by name.
    when: GetByNameRequested(registry, name)
    ensures: result = registry.all_projects.first(p => p.name = name)
}

rule ListAll {
    -- All registered projects.
    when: ListAllRequested(registry)
    ensures: result = registry.all_projects
}

rule ClearRegistry {
    -- Reset registry.  Testing only.
    when: ClearRegistryRequested(registry)
    ensures: registry.entries = {}
}


--- EQL Resolvers

rule ProjectByPathResolver {
    -- Pathom resolver: given :project/path, provides :project/name.
    when: PathomGraph.resolve(project_by_path, { path: String })
    let project = GetByPath(ProjectRegistry, path)
    ensures: result = { name: project.name or nil }
}

rule ProjectByNameResolver {
    -- Pathom resolver: given :project/name, provides :project/path.
    when: PathomGraph.resolve(project_by_name, { name: String })
    let project = GetByName(ProjectRegistry, name)
    ensures: result = { path: project.path or nil }
}

rule AllProjectsResolver {
    -- Pathom resolver: provides :project/all (list of all projects).
    when: PathomGraph.resolve(all_projects)
    ensures: result = { all: ListAll(ProjectRegistry) }
}


--- EQL Mutations

rule ProjectCreateMutation {
    -- Pathom mutation: create a new project.
    when: PathomGraph.mutate(project_create, { path: String, name: String? })
    ensures: result = { result: Register(ProjectRegistry, path, name) }
}

rule ProjectUpdateMutation {
    -- Pathom mutation: update project name.
    when: PathomGraph.mutate(project_update, { path: String, name: String })
    ensures: result = { result: UpdateProject(ProjectRegistry, path, { name: name }) }
}

rule ProjectDeleteMutation {
    -- Pathom mutation: remove project by path.
    when: PathomGraph.mutate(project_delete, { path: String })
    ensures: result = { result: Unregister(ProjectRegistry, path) }
}


--- Namespace Registration

rule RegisterResolversOnLoad {
    -- All project resolvers and mutations auto-register with PathomGraph
    -- when the resolver namespace is loaded.
    when: Namespace("task-conductor.project.resolvers").loaded
    ensures: PathomGraph.registered(
        project_by_path, project_by_name, all_projects,
        project_create, project_update, project_delete,
        execute, invoke_skill, escalate_to_dev_env
    )
}

rule RegisterStatechartsOnLoad {
    -- Task and story statecharts register with the statechart engine
    -- when the execute namespace is loaded.
    when: Namespace("task-conductor.project.execute").loaded
    ensures: StatechartEngine.registered(:execute/task, TaskStatechart)
    ensures: StatechartEngine.registered(:execute/story, StoryStatechart)
}


--- Orchestration Implementation: execute!
--
-- Concrete wiring for orchestration's Execute rule.
-- WorkOn → FetchTask → DeriveInitialState → StartStatechart → RegisterDevEnvHook.

rule ExecuteMutation {
    -- EQL mutation entry point.  Wires together mcp-tasks work-on,
    -- task fetch, state derivation, statechart start, and dev-env hook.
    when: PathomGraph.mutate(execute, { project_dir: String, task_id: Integer })

    -- 1. Set up worktree via mcp-tasks
    let worktree = WorkOn(project_dir, task_id)
    requires: worktree.error = nil

    -- 2. Fetch task data via EQL
    let task = FetchTask(worktree.path, task_id)
    requires: task.error = nil

    -- 3. Determine task type and fetch children for stories
    let is_story = task.type = story
    let children = if is_story: FetchChildren(worktree.path, task_id) else: []

    -- 4. Start statechart session
    let chart_id = if is_story: :execute/story else: :execute/task
    let session_id = StatechartEngine.start(chart_id, {
        project_dir: worktree.path,
        task_id: task_id,
        task_type: if is_story: story else: task
    })

    -- 5. Derive initial state
    let initial_state = if is_story:
        DeriveStoryState(task, children)
    else:
        DeriveTaskState(task)

    -- 6. Register dev-env on-idle hook if dev-env available
    ensures:
        let dev_env = SelectDevEnv(Registry)
        if dev_env exists:
            RegisterDevEnvHook(dev_env, session_id, on_idle, complete)

    ensures: result = {
        session_id: session_id,
        initial_state: initial_state,
        error: nil
    }
}


--- Orchestration Implementation: invoke-skill!
--
-- Virtual thread pattern for async skill invocation.
-- Stores on-complete + pre-skill state, launches Claude CLI, spawns
-- virtual thread that awaits result-promise then calls on-skill-complete.

rule InvokeSkillMutation {
    -- EQL mutation called from statechart entry actions.
    -- Returns immediately; background thread handles completion.
    when: PathomGraph.mutate(invoke_skill, {
        session_id: String,                        -- injected by statechart engine
        skill: String,                             -- skill name to invoke
        on_complete: TaskState?                    -- optional predetermined event
    })

    -- Store on_complete (clears any prior value when nil)
    ensures: session.on_complete = on_complete

    -- Snapshot state before skill runs
    ensures: StorePreSkillState(session)

    -- Launch Claude CLI with skill as prompt
    let handle = ClaudeCli.invoke(prompt: "/" + skill, dir: session.project_dir)

    -- Spawn virtual thread to await result
    ensures: VirtualThread.start(bound_fn {
        let result = handle.result_promise.await
        OnSkillComplete(session, result)
    })
    ensures: active_skill_threads.add(current_thread)

    ensures: result = { status: started }
}


--- Orchestration Implementation: escalate-to-dev-env!

rule EscalateToDevEnvMutation {
    -- EQL mutation called from statechart :escalated entry action.
    -- Selects dev-env, starts interactive session, registers on-close hook.
    when: PathomGraph.mutate(escalate_to_dev_env, { session_id: String })
    let data = StatechartEngine.get_data(session_id)
    let dev_env = SelectDevEnv(Registry)

    when dev_env exists:
        let opts = { dir: data.project_dir, task_id: data.task_id }
        let opts = if data.last_claude_session_id exists:
            opts with claude_session_id = data.last_claude_session_id
        else: opts
        ensures: StartSession(dev_env, session_id, opts)
        ensures: RegisterHook(dev_env, session_id, on_close,
            callback: OnDevEnvClose(session_id))
        ensures: result = { status: escalated, dev_env_id: dev_env.id }

    when dev_env = nil:
        ensures: result = {
            status: no_dev_env,
            error: { error: no_dev_env, message: "No dev-env available for escalation" }
        }
}


-- Implementation Notes
--
-- Virtual thread tracking:
--   active_skill_threads: atom holding Set<Thread> of running virtual threads.
--   await_skill_threads!: blocks until all tracked threads complete, loops to
--     catch cascading invocations where completing one skill triggers another.
--   reset_skill_threads!: clears atom, called during test cleanup.
--   bound_fn: conveys dynamic bindings to virtual thread, required for
--     nullable testing infrastructure.
--
-- Guard against session-not-found:
--   on_skill_complete and on_dev_env_close catch ExceptionInfo with
--   :session-not-found error, silently ignoring it.  This handles the case
--   where a session is stopped while an async operation is in flight.


-- Surfaces

surface ProjectRegistryApi {
    -- CRUD operations for project management.
    for consumer: Operator

    context registry: ProjectRegistry

    exposes:
        for project in registry.all_projects:
            project.path
            project.name

    provides:
        RegisterRequested(registry, path, name?)
        UnregisterRequested(registry, path)
        UpdateProjectRequested(registry, path, updates)
        GetByPathRequested(registry, path)
        GetByNameRequested(registry, name)
        ListAllRequested(registry)
}

surface ProjectExecutionApi {
    -- Concrete execution mutations for the orchestration layer.
    for consumer: Orchestrator

    provides:
        PathomGraph.mutate(execute, { project_dir, task_id })
        PathomGraph.mutate(invoke_skill, { session_id, skill, on_complete? })
        PathomGraph.mutate(escalate_to_dev_env, { session_id })
}


-- Open Questions

open_question "Should the registry support metadata on projects (e.g. task-conductor config path, default branch)?"
open_question "Should register! accept an idempotent option to return existing project instead of duplicate-path error?"
open_question "Should execute! verify the statechart engine has the chart registered before calling start!?"
open_question "Should invoke-skill! cap the number of concurrent virtual threads per session?"
