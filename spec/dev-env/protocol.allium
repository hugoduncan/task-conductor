-- DevEnv Protocol Specification
--
-- Abstract contract for hosting interactive Claude CLI sessions.
-- When a non-interactive CLI session needs human input, the orchestrator
-- launches an interactive session via a dev-env implementation.
--
-- Implementations (Emacs, terminal, etc.) spawn the Claude CLI process
-- directly. The JVM is notified of lifecycle events but does not own
-- the process.
--
-- Naming: allium uses snake_case (session_id, claude_session_id) per
-- language convention.  The Clojure implementation uses the equivalent
-- kebab-case (:session-id, :claude-session-id).


-- External Entities

external entity ClaudeSession {
    -- A Claude CLI session, managed outside this spec.
    id: String
}

external entity Event {
    -- Raw session event, structure implementation-defined.
    type: String
    timestamp: Timestamp
}


-- Value Types

value CallbackContext {
    session_id: String
    timestamp: Timestamp
    reason: user_exit | error | timeout
}

value SessionOpts {
    dir: String                                     -- working directory
    claude_session_id: String?                      -- CLI session to resume
    hooks: Map<String, String>?                     -- CLI hook commands keyed by event type
                                                    -- e.g. {UserPromptSubmit: "cmd", Notification: "cmd"}
    -- Note: The Clojure protocol also accepts :on-started callback in opts.
    -- Omitted here: opaque fn values are implementation-level wiring,
    -- not part of the domain contract.
}


-- Entities

entity DevEnv {
    id: String
    type: String                                    -- e.g. "emacs", "terminal"

    -- Derived
    is_connected: Boolean                           -- implementation-specific health check
}

entity Session {
    id: String
    dev_env: DevEnv
    claude_session_id: String                       -- the Claude CLI session being resumed
    dir: String                                     -- working directory
    status: starting | active | idle | closed
    close_reason: user_exit | error | timeout?      -- set when session closes

    -- Relationships
    hooks: Hook for this session

    -- Derived
    transcript: String?                             -- implementation-provided
    events: List<Event>?                            -- implementation-provided
}

entity Hook {
    id: String
    session: Session
    type: on_close                                  -- on_idle removed: CLI hooks handle idle detection
    -- callback is opaque and implementation-defined; not modelled as a field
}

entity Registry {
    -- Singleton: manages all dev-env instances.
    -- Each entry wraps a pre-constructed DevEnv protocol instance
    -- with a generated id, type, and metadata.
    entries: RegistryEntry for this registry

    -- Derived
    available: entries where entry.dev_env.is_connected = true
}

value RegistryEntry {
    id: String                                      -- generated by registry
    dev_env: DevEnv                                 -- protocol instance (opaque)
    type: String                                    -- e.g. "emacs", "terminal"
    meta: Map?                                      -- optional metadata
}


-- Config

config {
    command_response_timeout: Duration = 30.seconds
    ping_timeout: Duration = 5.seconds
    await_timeout: Duration = 60.seconds
}


-- Rules

--- Session Lifecycle

rule StartSession {
    -- session_id is caller-provided (e.g. ExecutionSession UUID).
    when: StartSessionRequested(dev_env, session_id, opts: SessionOpts)
    requires: dev_env.is_connected
    ensures: Session.created(
        id: session_id,
        dev_env: dev_env,
        claude_session_id: opts.claude_session_id,
        dir: opts.dir,
        status: starting
    )
}

rule SessionBecomeActive {
    -- Session transitions to active once the dev-env confirms it is running.
    when: session: Session.status becomes starting
    ensures: session.status = active
    -- Note: in practice, the dev-env implementation signals this transition.
    -- Modelled here as immediate for the protocol contract.
}

rule SessionBecomesIdle {
    -- Session transitions to idle when waiting for user input.
    when: SessionIdleDetected(session)
    requires: session.status = active
    ensures: session.status = idle
}

rule SessionResumesFromIdle {
    when: SessionActivityDetected(session)
    requires: session.status = idle
    ensures: session.status = active
}

rule CloseSession {
    when: CloseSessionRequested(dev_env, session_id)
    let session = Session with id = session_id
    requires: session.status in [starting, active, idle]
    let session_hooks = session.hooks
    ensures: session_hooks.each(h => not exists h)
    ensures: session.status = closed
}

rule SessionClosedByEvent {
    -- Session closed externally (user exit, error, timeout).
    when: SessionClosedExternally(session, reason)
    requires: session.status in [starting, active, idle]
    let session_hooks = session.hooks
    ensures: session.close_reason = reason
    ensures: session_hooks.each(h => not exists h)
    ensures: session.status = closed
}

--- Hook Management

rule RegisterHook {
    when: RegisterHookRequested(dev_env, session_id, hook_type, callback)
    let session = Session with id = session_id
    requires: session.status in [starting, active, idle]
    requires: hook_type = on_close
    ensures: Hook.created(
        session: session,
        type: hook_type,
        callback: callback
    )
}

rule FireOnCloseHooks {
    -- When a session closes, fire all on_close hooks before cleanup.
    when: session: Session.status becomes closed
    for hook in session.hooks with type = on_close:
        ensures: HookFired(hook, CallbackContext{
            session_id: session.id,
            timestamp: now,
            reason: session.close_reason
        })
}

-- Note: on_idle hooks removed.  Idle/active detection is now handled
-- by CLI hooks (UserPromptSubmit, Notification) passed via SessionOpts.hooks.
-- These hooks send :on-active and :on-session-idle events directly to the
-- statechart via clj-nrepl-eval.

--- Registry

rule RegisterDevEnv {
    -- dev_env is a pre-constructed protocol instance (opaque).
    -- The registry wraps it in an entry keyed by a generated id.
    when: RegisterDevEnvRequested(dev_env, type, meta)
    let id = new_dev_env_id                         -- generated string, e.g. "dev-env-12345"
    ensures: registry contains entry {
        id: id,
        dev_env: dev_env,                           -- stored, not modified
        type: type,
        meta: meta
    }
    ensures: result = id
}

rule UnregisterDevEnv {
    when: UnregisterDevEnvRequested(id)
    ensures: registry does not contain entry with id
    ensures: result = existed                       -- true if entry was present
}

rule SelectDevEnv {
    -- Select the first connected dev-env.
    -- Returns the dev-env entry or nil if none available.
    when: SelectDevEnvRequested(registry)
    let candidates = registry.available
    ensures: result =
        if candidates.count > 0: candidates.first
        else: nil
}

--- Health

rule Ping {
    -- Lightweight health check.
    when: PingRequested(dev_env)
    ensures:
        if dev_env.is_connected:
            PingSucceeded(dev_env)
        else:
            PingFailed(dev_env)
}

--- Querying

rule QueryTranscript {
    when: QueryTranscriptRequested(dev_env, session_id)
    requires: dev_env.is_connected
    let session = Session with id = session_id
    ensures: result = session.transcript
}

rule QueryEvents {
    -- Planned: not yet implemented.
    when: QueryEventsRequested(dev_env, session_id)
    requires: dev_env.is_connected
    let session = Session with id = session_id
    ensures: result = session.events
}

deferred QueryEvents.implementation    -- planned, not yet implemented


-- Surfaces

surface DevEnvRegistry {
    -- EQL query surface for discovering and selecting dev-envs.
    for consumer: Orchestrator

    context registry: Registry

    exposes:
        for entry in registry.entries:
            entry.id
            entry.type
            entry.dev_env.is_connected

    provides:
        RegisterDevEnvRequested(dev_env, type, meta)
        UnregisterDevEnvRequested(id)
        SelectDevEnvRequested(registry)
        PingRequested(entry.dev_env)
            when entry in registry.entries
}

surface SessionControl {
    -- EQL mutation surface for managing sessions.
    for consumer: Orchestrator

    context dev_env: DevEnv with is_connected = true

    exposes:
        for session in Session with dev_env = dev_env:
            session.id
            session.status
            session.claude_session_id

    provides:
        StartSessionRequested(dev_env, session_id, opts)
        CloseSessionRequested(dev_env, session_id)
            when session.status in [starting, active, idle]
        RegisterHookRequested(dev_env, session_id, hook_type, callback)
            when session.status in [starting, active, idle]
        QueryTranscriptRequested(dev_env, session_id)
        QueryEventsRequested(dev_env, session_id)
}


-- Open Questions

open_question "Should dev-env selection use ping-based health checks or trust cached connected? status?"
open_question "Should hook cleanup happen before or after on_close hooks fire? Current: hooks fire then are removed."
open_question "Should QueryEvents return structured event types or raw maps?"
open_question "Session idle detection â€” should the protocol define a standard idle timeout, or leave entirely to implementations?"
