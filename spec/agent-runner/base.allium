-- Agent Runner Base Specification
--
-- Composition layer that wires orchestration, dev-env protocol, and the
-- pathom graph into a running system.  The agent-runner owns bootstrap
-- (namespace discovery, transition listener, graph verification) and
-- exposes the public API: run-task!, run-story!, status.
--
-- The EQL execution model is central: statechart entry actions become
-- pathom mutations, resolver namespaces self-register on load, and the
-- graph is the single execution substrate for all side effects.
--
-- This spec documents what exists today in agent-runner core.clj.

use orchestration
use protocol


-- External Entities

external entity PathomGraph {
    -- The shared Pathom3 graph.  Resolvers and mutations auto-register
    -- on namespace load via pathom-graph component macros.
    env: Map                                    -- graph environment, nil when not operational
}

external entity Namespace {
    -- A loaded Clojure namespace containing resolvers or mutations.
    name: String
}


-- Value Types

value BootstrapResult {
    -- Returned by Bootstrap rule.
    namespaces: List<String>                    -- resolver namespace names discovered
    graph_operational: Boolean                  -- true when graph/env returns non-nil
}

value SessionStatus {
    -- Returned by QueryStatus rule.
    session_id: String
    current_state: Set<TaskState>               -- active states from statechart engine
    history: List<TransitionRecord>             -- ordered transition log
    error: Map?                                 -- present when session not found
}

value TransitionRecord {
    session_id: String
    from_state: TaskState
    to_state: TaskState
    event: TaskState
    timestamp: Timestamp
}


-- Rules

--- Bootstrap
--
-- Wiring the system: discover resolver namespaces, register transition
-- logging, verify the graph is operational.  Must be called once before
-- any execution.

rule Bootstrap {
    -- Discovers all loaded task-conductor.*.resolvers namespaces,
    -- registers a transition listener for logging, and verifies the
    -- pathom graph is operational.
    when: BootstrapRequested
    let resolver_ns = all loaded Namespace
        with name starts_with "task-conductor."
        and name ends_with ".resolvers"
    ensures: TransitionListenerRegistered(LogTransition)
    ensures: result = BootstrapResult {
        namespaces: resolver_ns.each(ns => ns.name),
        graph_operational: PathomGraph.env != nil
    }
}

rule LogTransition {
    -- Logs every statechart transition at info level.
    -- Registered once during bootstrap, fires for all sessions.
    when: TransitionOccurred(session_id, from_state, to_state, event)
    ensures: logged(session_id, from_state, to_state, event)
}


--- Execution Entry Points
--
-- Public API for starting supervised execution.  Both run-task and
-- run-story delegate to a shared execute-and-start sequence that
-- calls the orchestration Execute rule via EQL mutation, then sends
-- the initial state event to the statechart.

rule RunTask {
    -- Start supervised execution of a standalone task.
    when: RunTaskRequested(project_dir, task_id)
    ensures: ExecuteAndStart(project_dir, task_id)
}

rule RunStory {
    -- Start supervised execution of a story.
    -- Currently identical to RunTask; kept separate to allow divergence
    -- when story execution adds child-task orchestration beyond what
    -- the orchestration statechart provides.
    when: RunStoryRequested(project_dir, story_id)
    ensures: ExecuteAndStart(project_dir, story_id)
}

rule ExecuteAndStart {
    -- Shared execution sequence.
    -- 1. Call orchestration's execute! mutation via the pathom graph
    -- 2. On success, send initial-state event to start the statechart
    -- 3. Return session-id and current state
    when: ExecuteAndStartRequested(project_dir, task_id)
    let result = PathomGraph.mutate(
        orchestration/Execute,
        { project_dir: project_dir, task_id: task_id }
    )
    requires: result.error = nil
    ensures: orchestration/ExecutionSession.statechart.send(
        result.session_id,
        result.initial_state
    )
    ensures: result = {
        session_id: result.session_id,
        state: result.initial_state,
        error: nil
    }
}

rule ExecuteAndStartFailed {
    -- Error path: execute! mutation returned an error.
    when: ExecuteAndStartRequested(project_dir, task_id)
    let result = PathomGraph.mutate(
        orchestration/Execute,
        { project_dir: project_dir, task_id: task_id }
    )
    requires: result.error != nil
    ensures: result = {
        session_id: nil,
        state: nil,
        error: result.error
    }
}


--- Session Introspection

rule QueryStatus {
    -- Query the current state and transition history of a session.
    when: QueryStatusRequested(session_id)
    ensures: result = SessionStatus {
        session_id: session_id,
        current_state: orchestration/ExecutionSession.statechart_state(session_id),
        history: orchestration/ExecutionSession.history(session_id)
    }
}

rule QueryStatusNotFound {
    -- Session does not exist or has been stopped.
    when: QueryStatusRequested(session_id)
    requires: orchestration/ExecutionSession.statechart_state(session_id) = nil
    ensures: result = SessionStatus {
        session_id: session_id,
        error: { error: session_not_found }
    }
}


-- Surfaces

surface AgentRunnerApi {
    -- Public API for starting and monitoring agent execution.
    for consumer: Operator

    exposes:
        for session in orchestration/ExecutionSession:
            QueryStatusRequested(session.id)

    provides:
        BootstrapRequested
        RunTaskRequested(project_dir, task_id)
        RunStoryRequested(project_dir, story_id)
        QueryStatusRequested(session_id)
}


-- Open Questions

open_question "Should bootstrap verify that specific resolver namespaces are loaded, or is dynamic discovery sufficient?"
open_question "Should status expose the full ExecutionSession (project_dir, pre_skill_state, etc.) beyond current-state and history?"
open_question "Should run-task! and run-story! be unified into a single run! with task-type dispatch, since the orchestration statechart already handles both?"
