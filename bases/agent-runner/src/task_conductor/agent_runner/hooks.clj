(ns task-conductor.agent-runner.hooks
  "Stop hook generation and installation for Claude Code integration.

   Generates bash scripts that capture CLI exit status and write HookStatus
   EDN to the handoff file. The hook is automatically installed in Claude
   Code settings on story start."
  (:require
   [clojure.data.json :as json]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [task-conductor.agent-runner.handoff :as handoff])
  (:import
   [java.nio.file Files LinkOption]
   [java.nio.file.attribute PosixFilePermission]))

;;; Constants

(def hook-dir
  "Directory for hook scripts, under the handoff directory."
  (str handoff/hook-handoff-dir "/hooks"))

(def hook-filename "stop-hook.sh")
(def idle-hook-filename "idle-hook.sh")
(def settings-path ".claude/settings.local.json")

;;; Hook Generation

(defn generate-stop-hook
  "Generate bash script content for the stop hook.

   The script:
   - Reads JSON input from stdin (provided by Claude Code)
   - Writes HookStatus EDN to the handoff file (path from handoff/hook-handoff-path)
   - Uses atomic write (temp file + mv) for safety

   Returns the script content as a string."
  []
  (str/join
   "\n"
   ["#!/bin/bash"
    "# Claude Code stop hook - writes exit status to handoff file"
    "# Generated by task-conductor"
    ""
    "set -euo pipefail"
    ""
    "# Read JSON input from stdin (contains session_id, transcript_path, etc.)"
    "# We consume stdin but don't need the values for basic status reporting"
    "cat > /dev/null"
    ""
    "# Get current timestamp in ISO-8601 format"
    "TIMESTAMP=$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")"
    ""
    "# Determine status based on exit conditions"
    "# Default to :completed - error states will be set by the CLI itself"
    "STATUS=\":completed\""
    ""
    "# Write HookStatus EDN to handoff file"
    (str "HANDOFF_DIR=\"" handoff/hook-handoff-dir "\"")
    (str "HANDOFF_FILE=\"" handoff/hook-handoff-path "\"")
    "TEMP_FILE=\"$HANDOFF_DIR/.handoff.edn.tmp\""
    ""
    "# Ensure directory exists"
    "mkdir -p \"$HANDOFF_DIR\""
    ""
    "# Write to temp file first (atomic write pattern)"
    "cat > \"$TEMP_FILE\" << EOF"
    "{:status $STATUS"
    " :timestamp \"$TIMESTAMP\"}"
    "EOF"
    ""
    "# Atomic move"
    "mv \"$TEMP_FILE\" \"$HANDOFF_FILE\""
    ""
    "# Exit successfully to allow Claude to stop"
    "exit 0"
    ""]))

(defn generate-idle-hook
  "Generate bash script content for the idle notification hook.

   This hook fires when the Notification event triggers (60s idle timeout).
   It writes :idle status to the handoff file as a backup mechanism
   in case Emacs events fail.

   Returns the script content as a string."
  []
  (str/join
   "\n"
   ["#!/bin/bash"
    "# Claude Code idle notification hook - backup for 60s idle"
    "# Generated by task-conductor"
    ""
    "set -euo pipefail"
    ""
    "# Read JSON input from stdin (provided by Claude Code)"
    "# Contains session info, but we just need to signal idle status"
    "cat > /dev/null"
    ""
    "# Get current timestamp in ISO-8601 format"
    "TIMESTAMP=$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")"
    ""
    "# Write :idle HookStatus EDN to handoff file"
    (str "HANDOFF_DIR=\"" handoff/hook-handoff-dir "\"")
    (str "HANDOFF_FILE=\"" handoff/hook-handoff-path "\"")
    "TEMP_FILE=\"$HANDOFF_DIR/.handoff.edn.tmp\""
    ""
    "# Ensure directory exists"
    "mkdir -p \"$HANDOFF_DIR\""
    ""
    "# Write to temp file first (atomic write pattern)"
    "cat > \"$TEMP_FILE\" << EOF"
    "{:status :idle"
    " :timestamp \"$TIMESTAMP\""
    " :source :notification-hook}"
    "EOF"
    ""
    "# Atomic move"
    "mv \"$TEMP_FILE\" \"$HANDOFF_FILE\""
    ""
    "# Exit successfully"
    "exit 0"
    ""]))

;;; Hook Installation

(defn- ensure-directory!
  "Ensure directory exists, creating parent directories if needed."
  [path]
  (let [dir (io/file path)]
    (when-not (.exists dir)
      (.mkdirs dir))))

(defn- set-executable!
  "Set file as executable (chmod +x equivalent)."
  [path]
  (let [file (io/file path)
        link-opts (into-array LinkOption [])
        perms (Files/getPosixFilePermissions (.toPath file) link-opts)]
    (.add perms PosixFilePermission/OWNER_EXECUTE)
    (.add perms PosixFilePermission/GROUP_EXECUTE)
    (.add perms PosixFilePermission/OTHERS_EXECUTE)
    (Files/setPosixFilePermissions (.toPath file) perms)))

(defn install-stop-hook
  "Install the stop hook script to the project.

   Creates .task-conductor/hooks/stop-hook.sh and makes it executable.
   Returns the path to the installed hook."
  [project-root]
  (let [hooks-dir (io/file project-root hook-dir)
        hook-file (io/file hooks-dir hook-filename)]
    (ensure-directory! hooks-dir)
    (spit hook-file (generate-stop-hook))
    (set-executable! hook-file)
    (.getAbsolutePath hook-file)))

(defn install-idle-hook
  "Install the idle notification hook script to the project.

   Creates .task-conductor/hooks/idle-hook.sh and makes it executable.
   Returns the path to the installed hook."
  [project-root]
  (let [hooks-dir (io/file project-root hook-dir)
        hook-file (io/file hooks-dir idle-hook-filename)]
    (ensure-directory! hooks-dir)
    (spit hook-file (generate-idle-hook))
    (set-executable! hook-file)
    (.getAbsolutePath hook-file)))

;;; Claude Code Settings Configuration

(defn- read-settings
  "Read existing Claude Code settings, or return empty map if none."
  [project-root]
  (let [settings-file (io/file project-root settings-path)]
    (if (.exists settings-file)
      (json/read-str (slurp settings-file) :key-fn keyword)
      {})))

(defn- write-settings!
  "Write Claude Code settings to file."
  [project-root settings]
  (let [settings-file (io/file project-root settings-path)]
    (ensure-directory! (.getParent settings-file))
    (spit settings-file (json/write-str settings :indent true))))

(defn- stop-hook-path-relative
  "Get the stop hook path relative to project root."
  []
  (str hook-dir "/" hook-filename))

(defn- idle-hook-path-relative
  "Get the idle hook path relative to project root."
  []
  (str hook-dir "/" idle-hook-filename))

(defn- stop-hook-config
  "Generate the Stop hook configuration for Claude Code settings."
  []
  {:hooks [{:type "command"
            :command (stop-hook-path-relative)}]})

(defn- idle-hook-config
  "Generate the Notification (idle) hook configuration for Claude Code settings.
   Matches 'idle_prompt' notification type which fires after 60s idle."
  []
  {:matcher "idle_prompt"
   :hooks [{:type "command"
            :command (idle-hook-path-relative)}]})

(defn configure-claude-settings
  "Configure Claude Code settings to use the stop and idle hooks.

   Updates .claude/settings.local.json, preserving existing settings.
   Configures:
   - Stop hook: captures session completion
   - Notification hook: captures idle state after 60s (backup)

   Returns the updated settings map."
  [project-root]
  (let [current-settings (read-settings project-root)
        hooks (get current-settings :hooks {})
        updated-hooks (-> hooks
                          (assoc :Stop [(stop-hook-config)])
                          (assoc :Notification [(idle-hook-config)]))
        updated-settings (assoc current-settings :hooks updated-hooks)]
    (write-settings! project-root updated-settings)
    updated-settings))

;;; Main Entry Point

(defn stop-hook-installed?
  "Check if the stop hook is already installed."
  [project-root]
  (let [hook-file (io/file project-root hook-dir hook-filename)]
    (.exists hook-file)))

(defn idle-hook-installed?
  "Check if the idle hook is already installed."
  [project-root]
  (let [hook-file (io/file project-root hook-dir idle-hook-filename)]
    (.exists hook-file)))

(defn hook-installed?
  "Check if both stop and idle hooks are installed."
  [project-root]
  (and (stop-hook-installed? project-root)
       (idle-hook-installed? project-root)))

(defn settings-configured?
  "Check if Claude Code settings have both hooks configured."
  [project-root]
  (let [settings (read-settings project-root)
        stop-hooks (get-in settings [:hooks :Stop])
        notification-hooks (get-in settings [:hooks :Notification])
        stop-ok? (some #(= (stop-hook-path-relative)
                           (get-in % [:hooks 0 :command]))
                       stop-hooks)
        idle-ok? (some #(= (idle-hook-path-relative)
                           (get-in % [:hooks 0 :command]))
                       notification-hooks)]
    (boolean (and stop-ok? idle-ok?))))

(defn ensure-hooks-installed
  "Ensure stop and idle hooks are installed and configured (idempotent).

   Called on story start. Installs hook scripts and configures
   Claude Code settings if not already done.

   Returns a map with:
   - :stop-hook-path - path to the installed stop hook script
   - :idle-hook-path - path to the installed idle hook script
   - :settings-updated? - whether settings were modified"
  [project-root]
  (let [stop-installed? (stop-hook-installed? project-root)
        idle-installed? (idle-hook-installed? project-root)
        settings-ok? (settings-configured? project-root)
        stop-path (if stop-installed?
                    (.getAbsolutePath (io/file project-root hook-dir hook-filename))
                    (install-stop-hook project-root))
        idle-path (if idle-installed?
                    (.getAbsolutePath (io/file project-root hook-dir idle-hook-filename))
                    (install-idle-hook project-root))
        settings-updated? (when-not settings-ok?
                            (configure-claude-settings project-root)
                            true)]
    {:stop-hook-path stop-path
     :idle-hook-path idle-path
     :settings-updated? (boolean settings-updated?)}))
