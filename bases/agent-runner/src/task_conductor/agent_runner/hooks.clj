(ns task-conductor.agent-runner.hooks
  "Stop hook generation and installation for Claude Code integration.

   Generates bash scripts that capture CLI exit status and write HookStatus
   EDN to the handoff file. The hook is automatically installed in Claude
   Code settings on story start."
  (:require
   [clojure.data.json :as json]
   [clojure.java.io :as io]
   [clojure.string :as str]
   [task-conductor.agent-runner.handoff :as handoff])
  (:import
   [java.nio.file Files LinkOption]
   [java.nio.file.attribute PosixFilePermission]))

;;; Constants

(def hook-dir
  "Directory for hook scripts, under the handoff directory."
  (str handoff/hook-handoff-dir "/hooks"))

(def hook-filename "stop-hook.sh")
(def settings-path ".claude/settings.local.json")

;;; Hook Generation

(defn generate-stop-hook
  "Generate bash script content for the stop hook.

   The script:
   - Reads JSON input from stdin (provided by Claude Code)
   - Writes HookStatus EDN to the handoff file (path from handoff/hook-handoff-path)
   - Uses atomic write (temp file + mv) for safety

   Returns the script content as a string."
  []
  (str/join
   "\n"
   ["#!/bin/bash"
    "# Claude Code stop hook - writes exit status to handoff file"
    "# Generated by task-conductor"
    ""
    "set -euo pipefail"
    ""
    "# Read JSON input from stdin (contains session_id, transcript_path, etc.)"
    "# We consume stdin but don't need the values for basic status reporting"
    "cat > /dev/null"
    ""
    "# Get current timestamp in ISO-8601 format"
    "TIMESTAMP=$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")"
    ""
    "# Determine status based on exit conditions"
    "# Default to :completed - error states will be set by the CLI itself"
    "STATUS=\":completed\""
    ""
    "# Write HookStatus EDN to handoff file"
    (str "HANDOFF_DIR=\"" handoff/hook-handoff-dir "\"")
    (str "HANDOFF_FILE=\"" handoff/hook-handoff-path "\"")
    "TEMP_FILE=\"$HANDOFF_DIR/.handoff.edn.tmp\""
    ""
    "# Ensure directory exists"
    "mkdir -p \"$HANDOFF_DIR\""
    ""
    "# Write to temp file first (atomic write pattern)"
    "cat > \"$TEMP_FILE\" << EOF"
    "{:status $STATUS"
    " :timestamp \"$TIMESTAMP\"}"
    "EOF"
    ""
    "# Atomic move"
    "mv \"$TEMP_FILE\" \"$HANDOFF_FILE\""
    ""
    "# Exit successfully to allow Claude to stop"
    "exit 0"
    ""]))

;;; Hook Installation

(defn- ensure-directory!
  "Ensure directory exists, creating parent directories if needed."
  [path]
  (let [dir (io/file path)]
    (when-not (.exists dir)
      (.mkdirs dir))))

(defn- set-executable!
  "Set file as executable (chmod +x equivalent)."
  [path]
  (let [file (io/file path)
        link-opts (into-array LinkOption [])
        perms (Files/getPosixFilePermissions (.toPath file) link-opts)]
    (.add perms PosixFilePermission/OWNER_EXECUTE)
    (.add perms PosixFilePermission/GROUP_EXECUTE)
    (.add perms PosixFilePermission/OTHERS_EXECUTE)
    (Files/setPosixFilePermissions (.toPath file) perms)))

(defn install-stop-hook
  "Install the stop hook script to the project.

   Creates .task-conductor/hooks/stop-hook.sh and makes it executable.
   Returns the path to the installed hook."
  [project-root]
  (let [hooks-dir (io/file project-root hook-dir)
        hook-file (io/file hooks-dir hook-filename)]
    (ensure-directory! hooks-dir)
    (spit hook-file (generate-stop-hook))
    (set-executable! hook-file)
    (.getAbsolutePath hook-file)))

;;; Claude Code Settings Configuration

(defn- read-settings
  "Read existing Claude Code settings, or return empty map if none."
  [project-root]
  (let [settings-file (io/file project-root settings-path)]
    (if (.exists settings-file)
      (json/read-str (slurp settings-file) :key-fn keyword)
      {})))

(defn- write-settings!
  "Write Claude Code settings to file."
  [project-root settings]
  (let [settings-file (io/file project-root settings-path)]
    (ensure-directory! (.getParent settings-file))
    (spit settings-file (json/write-str settings :indent true))))

(defn- hook-path-relative
  "Get the hook path relative to project root."
  []
  (str hook-dir "/" hook-filename))

(defn- stop-hook-config
  "Generate the Stop hook configuration for Claude Code settings."
  []
  {:hooks [{:type "command"
            :command (hook-path-relative)}]})

(defn configure-claude-settings
  "Configure Claude Code settings to use the stop hook.

   Updates .claude/settings.local.json, preserving existing settings.
   Returns the updated settings map."
  [project-root]
  (let [current-settings (read-settings project-root)
        hooks (get current-settings :hooks {})
        updated-hooks (assoc hooks :Stop [(stop-hook-config)])
        updated-settings (assoc current-settings :hooks updated-hooks)]
    (write-settings! project-root updated-settings)
    updated-settings))

;;; Main Entry Point

(defn hook-installed?
  "Check if the stop hook is already installed."
  [project-root]
  (let [hook-file (io/file project-root hook-dir hook-filename)]
    (.exists hook-file)))

(defn settings-configured?
  "Check if Claude Code settings already have the stop hook configured."
  [project-root]
  (let [settings (read-settings project-root)
        stop-hooks (get-in settings [:hooks :Stop])]
    (boolean
     (some #(= (hook-path-relative) (get-in % [:hooks 0 :command]))
           stop-hooks))))

(defn ensure-hooks-installed
  "Ensure stop hooks are installed and configured (idempotent).

   Called on story start. Installs the hook script and configures
   Claude Code settings if not already done.

   Returns a map with:
   - :hook-path - path to the installed hook script
   - :settings-updated? - whether settings were modified"
  [project-root]
  (let [hook-exists? (hook-installed? project-root)
        settings-ok? (settings-configured? project-root)
        hook-path (if hook-exists?
                    (.getAbsolutePath (io/file project-root hook-dir hook-filename))
                    (install-stop-hook project-root))
        settings-updated? (when-not settings-ok?
                            (configure-claude-settings project-root)
                            true)]
    {:hook-path hook-path
     :settings-updated? (boolean settings-updated?)}))
